= Отчет по лабораторной работе №7
Шумаков А.С. <КЭ-413>
:imagesdir: image
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:sectnums: |,all|

Целью 7 работы является создать функцию, которая делает тактирование от системного таймера, а потом переделать ее так, чтобы тактирование было от таймера 2.

== Таймеры

Одной из главных функций таймеров в микроконтроллерах является отсчет точных временных интервалов. 
Однако таймеры также могут применяться для измерения частоты и периодов, а также для генерации ШИМ и сигналов переменной формы.

В микроконтроллере STM32F411RET6 имеются следующие таймеры:

.Таймеры
image::Timers.jpg[]

== Системный таймер

Самый просто таймер, встроенный в ядро ARMv7, на котором построено ядро CortexM4 и наш микроконтроллер stm32F411, 
т.e. его поддерживают все микроконтроллеры на этом ядре.

для настройки системного таймера используется 3 регистра:

* SysTick Control and Status Register (SYST_CSR)
* Регистр перезагружаемого значения LOAD
* Регистр текущего значения VAL

=== SysTick Control and Status Register (SYST_CSR)

Регистр SYST_CSR - это 32 битный регистр для управления системным таймером

.Регистр SYST_CSR
image::SYST_CSR.jpg[]

.Поля регистра SYST_CSR

[cols="a, a, a,  7"]
|===
|Биты |Доступ |Обозначение |Описание

| 31:17
|
|
| Зарезервировано

| 16
| Read/Rewrite
| COUNTFLAG
| Показывает, дошёл ли счётчик до нуля с момента последнего считывания этого регистра:

*NoOverflow* (0) — счётчик ещё не достигал нуля

*Overflow* (1) — счётчик достигал нуля

Этот бит сбрасывается считыванием данного регистра, а также записью значения в регистр SYST_CVR. Его установка производится, когда значение cчётчика переходит из 1 в 0

| 15:3
|
|
|Зарезервировано

| 2
| Read/Write
| CLKSOURCE
| Выбирает источник синхронизации для таймера:

*ExternalClock*(0) — используется внешний источник

*CpuClock* (1) — для синхронизации используется частота процессора


| 1
| Read/Write
| TICKINT
| Определяет, будет ли генерироваться запрос на прерывание при достижении счетчиком 0:

*DisableInterrupt* (0) — запрос прерывания не выдаётся

*EnableInterrupt* (1) — запрос прерывания выдаётся

Достижением нуля считается только декремент значения счётчика, приводящий к появлению в нём нуля, но не его сброс в результате явной записи в регистр SYST_CVR

| 0
| Read/Write
| ENABLE
| Определяет, разрешена ли работа таймера (уменьшение счётчика):

*Disable*(0) — счётчик выключен

*Enable* (1) — счётчик включён

|===


=== Регистр перезагружаемого значения LOAD

Регистр LOAD - это 32 битный регистр, из которого используются только первые 24 бита. 
В этом регистре хранится значение, которое будет записано в системный таймер как только его счетчик достигнет 0.

=== Регистр текущего значения VAL

Регистр VAL - это 32 битный регистр, из которого используются только первые 24 бита. В этом регистре хранится текущее значение счетчика.

== Алгоритм работы с системным таймером

С помощью системного таймера можно установить практически любое значение задержки, для чего необходимо:

* Записать значение задержки в регистр LOAD. Поскольку счетчик системного таймера уменьшается на 1 с каждым тактом процессора, можно легко рассчитать, что если системная частота микроконтроллера подключена к внутреннему источнику тактирования HSI, то для создания задержки в 1 мс нужно записать в этот регистр значение (16'000'000/1000 - 1). 
Счетчик начнет уменьшаться с этого значения на 1 при каждом такте процессора, и как только он достигнет 0, в регистре ICSR в поле PENDSTSET (26 бит) установится флаг прерывания.

* Установить текущее значение счетчика в регистр VAL на 0.

* Подключить системный таймер к частоте процессора в регистре CTRL.

* Включить системный таймер в регистре CTRL.

* Дождаться установки флага PENDSTSET в регистре ICSR.

== Реализация системного таймера

[[pointer_code1]]
[source, cpp]

----

#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ
#include <array>
#include "stkregisters.hpp" // for SystemTimer
#include "scbregisters.hpp" // for ISCR register

#include "ILed.h"
#include "Led.h" // ????? Led
#include "ledconfig.h" //???????????? Led


#include "IMode.h" // ????????? IMode
#include "allmode.h" // ????? AllMode
#include "treemode.h" // ????? TreeMode
#include "chessmode.h" // ????? ChessMode
#include "modeconfig.h" //???????????? Mode
#include "IButton.h" // ????????? IButton
#include "Button.h"
#include "ModeManager.h"

std::uint32_t SystemCoreClock = 16'000'000U;



extern "C" {
int __low_level_init(void)
{
//Switch on external 8 MHz oscillator
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{

}
//Switch the system clock to HSI
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{

}

RCC::APB2ENR::SYSCFGEN::Enable::Set();

STK::CTRL::CLKSOURCE::CpuClock::Set();

return 1;
}
}

void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
  //Посчитать значение задержки
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * timeInMs;
 //Записать в регистре load значение задержки
  STK::LOAD::Write(timerDelayCounts - 1);
// Записать текущее значение задержки
  STK::VAL::Write(0);
//Включить системный таймер в регистре CTRL

  STK::CTRL::ENABLE::Enable::Set();

  while(STK::CTRL::COUNTFLAG::NoOverflow::IsSet())
  {
  }

//Отключить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Disable();
}

int main()
{
RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
RCC::AHB1ENR::GPIOCEN::Enable::Set();

GPIOC::MODER::MODER13::Input::Set();


GPIOA::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER8::Output::Set() ;
GPIOC::MODER::MODER9::Output::Set() ;



Led<GPIOC, 5> led1;
Led<GPIOC, 8> led2;
Led<GPIOC, 9> led3;
Led<GPIOA, 5> led4;


tLeds leds = { &led1, &led2, &led3, &led4 };

    TreeMode TreeMode(leds);
    ChessMode ChessMode(leds);
    AllMode AllMode(leds);

    tMode modes = { &TreeMode, &ChessMode, &AllMode };

    ModeManager modeManager(modes);
    modeManager.InitModeManager();

    Button<GPIOC, 13> button;


   for(;;)
  {
    modeManager.UpdateModeManager();

    if (button.IsClick())
    {
      modeManager.SwitchModeManager();
    }
    delay(200);
  }
  
  return 1;
}
----

Таким образом, функция delay() была сконфигурирована таким образом, что на входе принимает время в миллисекундах.
Например, при вызове delay(200) устанавливается задержка на 200 мс.

== Таймер TIM2

Таймер TIM2 является 32-битным. Он имеет следуюющие возможности:

* работа с инкрементальными энкодерами и датчиками Холла
* возможность синхронизировать несколько таймеров между собой
* захват сигнала (защелкивать значение, когда на выводе порта например 0 сменился на 1)
* генерации ШИМ (Генерировать прямоугольный сигнал с различной скважностью на вывод порта)
* генерации одиночного импульса

Таймер TIM2 может генеририровать следующие события:

* Переполнение

* Захват сигнала

* Сравнение

* Событие-триггер

== Регистры для режима счета TIM2

* TIMx::CNT:

Cчетный 16/32 разрядный регистр таймера суммирующий, с приходом каждого тактового импульса инкрементирует свое содержимое. На вычитание работать не может. ​

* TIMx::PSC:

16 разрядный регистр - делитель частоты для таймера. Коэффициент деления задается в 16-разрядном регистре, этот коэффициент можно задать в пределах от 1 до 65536.​

* TIMx::ARR:

​16/32 разрядный регистр автоперезагрузки. В этот регистр записывается число, до которого будет идти счет. При достижении этого значения, содержимое счетчика TIMx_CNT обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

* TIMx::SR:

​Регистр статуса. Можно узнать о всех возможных запросах на прерывания от таймера

== Управляющий регистр (CR1)

Основные настройки таймера производятся через регистр CR1. Нам понадобятся всего несколько бит.

.Управляющий регистр CR1
image::CR1.jpg[]

.Управляющий регистр CR1

[horizontal]
[cols="a, a"]
|===
|Бит | Описание

|Bit 2: URS
|Источник генерации прерываний​

* *0*: Любые из следующих событий будут генерировать прерывание или запрос DMA, если они включены:​
** Переполнение счетчика​ или установлен UG бит​
* *1*: Только после переполнения счетчика может сгенерировать прерывание или запрос DMA​

|Bit 1: UDIS
|Отключить событие по изменению (Update Event)​

* *0*: UEV включен. Событие по изменению(UEV) генерируются следующими событиями:​
 ** Переполнение счетчика​ или установлен UG бит​
* *1*: UEV отключен. ​

|Bit 0 CEN
|Включить счетчик​

* *0*: Counter выключен​
* *1*: Counter включен​
|===

== Регистр статуса (SR)

Регистр SR хранит статусы запросов на прерывания

.Регистр SR
image::SR.jpg[]

.биты регистра SR

[cols="a, a"]
|===
|Бит | Описание

|Bit0: UIF
|Флаг прерывания по событию обновления. Бит устанавливается аппаратно, скидываться должен программно​

* *0*: Флаг прерывания сбршен​
* *1*: Флаг прерывания установлен​

|===

== Принцип работы с Таймером TIM2

* Подать тактирование на модуль таймера​

* Установить делитель частоты для таймера в регистре PSC​

* Установить источник генерации прерываний по событию переполнение с помощью бита URS в регистре CR1​

* Установить значение до которого счетчик будет считать в регистре перезагрузке ARR​

* Скинуть флаг генерации прерывания UIF по событию в регистре SR​

* Установить начальное значение счетчика в 0 в регистре CNT​

* Запустить счетчик с помощью бита EN в регистре CR1​

* Проверять пока не будет установлен флаг генерации прерывания по событию UIF в регистре SR​

* Как только флаг установлен остановить счетчик, сбросить бит EN в регистре CR1, Сбросить флаг генерации прерывания UIF по событию в регистре SR

== Реализация работы TIM2

[[pointer_code1]]
[source, cpp]

----

#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ
#include <array>
#include "stkregisters.hpp" // for SystemTimer
#include "scbregisters.hpp" // for ISCR register
#include "tim2registers.hpp" // for TIM2

#include "ILed.h"
#include "Led.h" // ????? Led
#include "ledconfig.h" //???????????? Led


#include "IMode.h" // ????????? IMode
#include "allmode.h" // ????? AllMode
#include "treemode.h" // ????? TreeMode
#include "chessmode.h" // ????? ChessMode
#include "modeconfig.h" //???????????? Mode
#include "IButton.h" // ????????? IButton
#include "Button.h"
#include "ModeManager.h"

std::uint32_t SystemCoreClock = 16'000'000U;



extern "C" {
int __low_level_init(void)
{
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{

}
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{

}

RCC::APB1ENR::TIM2EN::Enable::Set();


return 1;
}
}

void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
  
  const auto prescalerValue = SystemCoreClock / 1000U - 1U;
  
  TIM2::PSC::Write(prescalerValue);
  
  TIM2::CR1::URS::Set(0);
  
  TIM2::ARR::Write(timeInMs);
  
  TIM2::SR::UIF::Set(0);
  
  TIM2::CNT::Write(0);
  
  TIM2::CR1::CEN::Enable::Set();
  while(TIM2::SR::UIF::NoInterruptPending::IsSet())

  {
  }
  TIM2::CR1::CEN::Disable::Set();

}

int main()
{
RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
RCC::AHB1ENR::GPIOCEN::Enable::Set();

GPIOC::MODER::MODER13::Input::Set();


GPIOA::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER8::Output::Set() ;
GPIOC::MODER::MODER9::Output::Set() ;




Led<GPIOC, 5> led1;
Led<GPIOC, 8> led2;
Led<GPIOC, 9> led3;
Led<GPIOA, 5> led4;

tLeds leds = { &led1, &led2, &led3, &led4 };

    TreeMode TreeMode(leds);
    ChessMode ChessMode(leds);
    AllMode AllMode(leds);

    tMode modes = { &TreeMode, &ChessMode, &AllMode };

    ModeManager modeManager(modes);
    modeManager.InitModeManager();

    Button<GPIOC, 13> button;


   for(;;)
  {
    modeManager.UpdateModeManager();

    if (button.IsClick())
    {
      modeManager.SwitchModeManager();
    }
    delay(200);
  }
  
  return 1;
}
----

== Вывод

В результате лабораторной работы была разработана функция задержки delay() с использованием системного таймера SysTick и таймера общего назначения TIM2.