= Отчет по лабораторной работе №1
Шумаков А.С. <КЭ-413>
:imagesdir: image
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:sectnums: |,all|

== Процесс разработки ПО
Процесс разработки ПО включает в себя несколько этапов:

.	Анализ требований
Анализ требований, это процесс, в который входит сбор необходимых требований для работы ПО и определение способов выполнений требований.
.	Проектирование программного обеспечения
Проектирование программного обеспечения - это этап в котором, разрабатывается архитектура системы, выбирается алгоритм решения задачи.
.	Программирование.
Процесс, в котором выбирается язык программирования и пишется код, реализующий необходимый функционал ПО.
.	Тестирование
Процесс, при котором проходит проверка работы ПО, находятся ошибки, с последующим устранением.
.	Обслуживание ПО
Процесс выявления и устранения ошибок ПО после внедрения в эксплуатацию, а также последующее улучшение ПО.
 
 
.План разработки ПО
image::PlanDevelopment.png[]

== Компиляция кода
Компиляция представляет собой процесс обработки исходных файлов кода, таких как .c, .cc или .cpp, с целью создания объектного файла. 

На данном этапе еще не создается исполняемый файл, который мог бы быть запущен пользователем. 
Компилятор просто генерирует инструкции на машинном языке, соответствующие скомпилированному исходному коду. 

Например, при компиляции трех отдельных файлов вы получите три объектных файла с расширениями .o или .obj, в зависимости от используемого компилятора. 

Эти файлы содержат перевод вашего кода на машинный язык, однако их запуск в данный момент невозможен. 
Для этого необходимо преобразовать их в исполняемые файлы, что и делает компоновщик.

.Компановка
image::kompomovshik.png[]

== Линковка
Линковка представляет собой процесс, в ходе которого создается один исполняемый файл из нескольких объектных файлов. На этом этапе компоновщик часто сталкивается с неопределенными функциями, особенно с основной функцией main. 

Во время компиляции, если компилятор не находит определение для какой-либо функции, он предполагает, что это определение есть в другом файле. Однако, поскольку компилятор не анализирует несколько файлов одновременно, он не может выявить, если функция не существует. 

Компоновщик, в отличие от компилятора, способен просматривать несколько файлов и искать ссылки на функции, которые не были определены.
Разделение процесса на этапы компиляции и линковки имеет свои причины: 

Во-первых, это упрощает реализацию, так как каждый компонент выполняет свою задачу, что снижает общую сложность программы.

Во-вторых, такое разделение позволяет работать с большими программами, избегая необходимости повторной компиляции всех файлов при каждом изменении. 

С помощью "условной компиляции" можно компилировать только те исходные файлы, которые были изменены, в то время как остальные объектные файлы остаются в силе для компоновщика. Это также упрощает работу с библиотеками предварительно скомпилированного кода, позволяя связывать объектные файлы так же, как и любые другие.

Чтобы эффективно воспользоваться преимуществами условной компиляции, лучше использовать специальные утилиты, чем пытаться вспомнить, какие файлы были изменены. 

Интегрированные среды разработки (IDE) могут автоматически обрабатывать этот процесс, а для пользователей командной строки существует утилита make, которая доступна в большинстве дистрибутивов *nix и предлагает множество функций для управления компиляцией, включая создание различных версий программы.

Понимание различий между компиляцией и линковкой может помочь в поиске ошибок. 

Ошибки компиляции, как правило, связаны с синтаксисом, такими как пропущенные точки с запятой или лишние скобки. 

Ошибки линковки чаще возникают из-за отсутствующих или дублирующихся определений. Если компоновщик сообщает о том, что функция или переменная определена несколько раз, это может указывать на наличие одинаковых функций или переменных в разных исходных файлах.

== Запуск кода на миконтроллире
Функция int main() является начальной точкой программы. На самом деле, до ее вызова микроконтроллер выполняет различные действия, такие как инициализация стека, глобальных переменных и констант. 

После включения питания происходит инициализация указателя стека. Микроконтроллер начинает работу с адреса,который определен спецификацией, где находится таблица векторов прерываний. Инициализация нулевой памяти происходит перед вызовом функции main(). Далее происходит инициализация данных, скопированных из ПЗУ в ОЗУ. 

Завершающим этапом является вызов функции main(). Перед ее запуском необходимо инициализировать стек, переменные и обработчики прерываний, если они используются в проекте.

== Стек
Стеком называется упорядоченный набор элементов, в котором размещение новых и удаление существующих происходит с одного конца, называемого вершиной. 
Принцип работы стека сравнивают со стопкой листов бумаги: чтобы взять второй сверху, нужно снять верхний.

.Стек
image::Stack.png[]

Виды стека:

•	Аппаратный стек используется для хранения адресов возврата из функций и их аргументов.

•	Программный стек – это пользовательская модель данных.

Существует несколько способов реализации стека:

•	с помощью одномерного массива;

•	с помощью классов объектно-ориентированного программирования;

•	с помощью связанного списка;

•	с использованием шаблонов проектирования STL.

Размер стека оказывает значительное влияние на работу программы в нескольких ключевых аспектах:


.	Скорость выполнения программы: при увеличении размера стека у программы появляется больше памяти для хранения временных данных и локальных переменных. Это может ускорить выполнение, так как процессору не придется обращаться к оперативной памяти за необходимыми данными, что снижает время доступа и повышает общую производительность.

.	Риск переполнения стека: если размер стека оказывается недостаточным для потребностей программы, существует вероятность переполнения. Это может привести к аварийному завершению работы программы или вызвать непредсказуемое поведение, что существенно затруднит отладку и использование приложения.

.	Рекурсивные вызовы функций: в случае выполнения рекурсивных функций каждый новый вызов добавляет новый фрейм в стек. При слишком большом количестве рекурсивных вызовов может произойти переполнение стека, что также приведет к сбоям в работе программы.

.	Использование системных ресурсов: увеличение размера стека приводит к большему потреблению оперативной памяти. Это может стать проблемой для систем с ограниченными ресурсами, где важно оптимально распределять доступную память.

== Ответы на вопросы

1	Дайте определение понятию "Интегрированной среде разработки"

Ответ: 
Интегрированная среда разработки – это программное обеспечение, которое объединяет в себе инструменты, необходимые программистам для разработки, тестирования и отладки программного обеспечения.

.Пример интегрированной среды разработки
image::PrimerProga.png[]

2 Что такое компилятор и чем он отличается от транслятора?

Ответ: 

Компилятор - это программа, которая преобразует исходный код, написанный на высокоуровневом языке программирования, в машинный код или промежуточный код, который может быть выполнен компьютером.

.Работа компилятора
image::WorkKomp.png[]

Разница между компилятором и транслятором в, том что компилятор читает всю программу целиком, делает её перевод и создаёт законченный вариант на машинном языке, который затем и выполняется, а транслятор, переводит и выполняет программу строка за строкой
3	Что такое компоновщик и какие функции он выполняет?

Ответ:

Компоновщик – инструментальная программа, которая производит компоновку: принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
Для связывания модулей компоновщик использует таблицы символов, созданные компилятором в каждом из объектных модулей.

4	Почему важен процесс проектирования ПО какие задачи входят в этот процесс?

Ответ:

Процесс проектирования ПО важен, потому что он позволяет заранее продумать принцип работы программы, способы её реализации,  также благодаря этому можно продумать все необходимые этапы в разработке.

5	Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки остановки?

Ответ:

Отладка - это процесс при котором тестируется программа и обнаруживаются ошиьки в коде