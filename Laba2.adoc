= Отчет по лабораторной работе №2
Шумаков А.С. <КЭ-413>
:imagesdir: image
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:sectnums: |,all|

== Типы данных
Типы данных — это категории, которые определяют, какие значения могут храниться в переменных и какие операции могут быть выполнены с этими значениями. 

Есть следующие типы данных:

•Простые:

Целые:

.   bool - Представляет значения, которые могут быть или true, или false.

.   char - Используется для символов ASCII в старых строках в стиле C или в объектах std::string, которые никогда не будут преобразовываться в Юникод.

.   int - Целочисленное значение. Выбор по умолчанию для целых чисел.

С плавающей точкой:

. float - Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами.

. double - Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей точкой.

. long double - Число с плавающей точкой двойной точности с двойной точностью.

•Структурированные:

. array - тип данных в информатике, представляющий упорядоченный набор однотипных элементов.

. union - представляет собой значение или структуру данных, которое может иметь несколько различных представлений.

. struct - Это объединение нескольких объектов, возможно, различного типа под одним именем.

•Адрессные:

.   pointer - это тип данных, который представляет собой переменную, диапазон значений которой состоит из адресов ячеек памяти или специального значения — нулевого адреса.
.   reference - это объект, указывающий на определённые данные, но не хранящий их.

== Смешивание данных

Смешивание типов данных может привести к непредсказуемым результатам или ошибкам в программе. Каждый тип данных имеет свои собственные правила и спецификации, поэтому не все их можно просто смешивать между собой. Например, операции над числами не будут работать корректно, если одно из чисел будет строкой.

Также, смешивание типов данных усложняет чтение и понимание кода, делая его менее читаемым и поддерживаемым.

==   Неявное преобразование типов

Неявное преобразование типов  — это процесс, при котором язык программирования автоматически преобразует один тип данных в другой без явного указания программиста.

Оно происходит в различных ситуациях, например:

•   При операциях с разными типами данных. Меньший тип автоматически преобразуется в больший. Например, при сложении int и double, тип int будет преобразован в double.

•   При присваивании значения переменной другого типа. Значение автоматически преобразуется. Например, при присваивании double значению int, дробная часть будет отброшена.

•   При передаче аргументов функции. Когда аргумент функции имеет тип, отличный от типа параметра, аргумент преобразуется в тип параметра. Это часто происходит при вызове функций стандартной библиотеки. 

==   Явное преобразование типов

Явное преобразование типов  — это процесс, при котором программист явно указывает, как один тип данных должен быть преобразован в другой. 

Существует несколько способов выполнения явного преобразования типов в C++: 

C-стиль приведение - способ является наследием языка C и выглядит следующим образом: int a = 10; double b = (double)a. В этом примере переменная a типа int явно приводится к типу double.

Функциональное приведение - метод использующий синтаксис вызова функции и выглядит более читаемым для некоторых программистов: int a = 10; double b = double(a);. Эффект от этого приведения тот же самый, что и у С-стиля.

Static_cast - оператор, использующийся для обычных преобразований между типами, которые заранее известны и понятны: int a = 10; double b = static_cast<double>(a);. Использование static_cast предпочтительнее, так как оно более безопасное и наглядное.

Dynamic_cast - оператор, использующийся главным образом для преобразования указателей и ссылок на объекты базовых классов в указатели и ссылки на объекты производных классов.

Reinterpret_cast - оператор, использующийся для преобразований одного типа данных в другой, которые не являются безопасными. Применять reinterpret_cast следует очень осторожно, так как оно может привести к платформо-зависимому и неопределённому поведению. 

== Использование встроенных типов

Использование встроенных типов данных в программировании в некоторых случаях может привести к определённым проблемам или недостаткам. Вот несколько причин, почему использование встроенных типов может быть нежелательным в определённых контекстах:

. Ограниченная функциональность:
   Встроенные типы часто имеют ограниченные возможности по сравнению с пользовательскими типами. Например, встроенные типы могут не поддерживать методы, которые необходимы для специфических задач.

. Отсутствие семантики:
   Встроенные типы могут не иметь явной семантики (семантика - это начальное смысловое значение операторов, основных конструкций языка.) для определенных доменных областей (доменная область - множество всех возможных значений, которые переменная может принимать). 
   Например, использование целых чисел для представления идентификаторов может быть неочевидно, если не использовать соответствующий класс или структуру.

. Проблемы с читаемостью и поддержкой:
   Код, который активно использует встроенные типы, может быть менее читаемым и понятным. Пользовательские типы могут лучше отражать логику и структуру данных, что упрощает поддержку и понимание кода.

. Отсутствие проверки типов:
   В некоторых языках, особенно динамически типизированных, использование встроенных типов может привести к ошибкам, связанным с неправильным использованием типов. Пользовательские типы могут включать в себя дополнительные проверки и ограничения, что уменьшает количество ошибок.
   C++ не является динамически типизированным.
   
   Пример использования встроенных типов:

const char *st = "Цена бутылки вина\n";

int main() 

{

  int len = 0;

  while ( st++ ) ++len;

  cout << len << ": " << st;

  return 0;

}


. Проблемы с производительностью:
   В некоторых случаях встроенные типы могут быть менее эффективными с точки зрения производительности по сравнению с оптимизированными пользовательскими типами. Например, работа с большими массивами встроенных типов может быть менее эффективной, чем использование специализированных структур.

   Пример использования специализированных структур:

   struct building {
    char *owner;  // владелец
    char *city;  // название города
    int amountRooms;  // количество комнат
    float price;  // цена
}

int main() {

    setlocale (LC_ALL, "rus");

    building apartment1;  // это объект структуры с типом данных, именем структуры, building

    apartment1.owner = "Денис";  // заполняем данные о владельце и т.д.

    apartment1.city = "Симферополь";

    apartment1.amountRooms = 5;

    apartment1.price = 150000;

    cout << "Владелец квартиры: " << apartment1.owner << endl;

    cout << "Квартира находится в городе: " << apartment1.city << endl;

    cout << "Количество комнат: " << apartment1.amountRooms << endl;

    cout << "Стоимость: " << apartment1.price << " $" << endl;

    return 0;
}

. Проблемы с расширяемостью:
   Встроенные типы часто не могут быть расширены или изменены. Если вам необходимо добавить дополнительные свойства или методы, вам может потребоваться создать новый тип, что может увеличить сложность кода.

. Общая зависимость от языка:
   Использование встроенных типов может сделать код более зависимым от конкретного языка программирования. Пользовательские типы могут быть более универсальными и легко адаптируемыми для различных языков.

== Функции преобразования

Существует несколько различных типов функций преобразования данных, включая:

.   Преобразование типов данных - преобразование одного типа данных в другой, например, из строки в число или из числа в строку.

Пример использования std::stoi для преобразования строки в целое число:

#include <iostream>

#include <string>

int main() 

{

    std::string str = "123";

    int num = std::stoi(str);
    
    std::cout << "Число: " << num << std::endl;
    
    return 0;
}


.   Кодирование данных - преобразование данных из одной кодировки в другую, например, из UTF-8 в ASCII.

.   Шифрование данных - преобразование данных с использованием специального алгоритма шифрования для обеспечения конфиденциальности.

.   Дешифрование данных - обратное преобразование зашифрованных данных в исходное состояние.

== Распределение памяти ОЗУ в микроконтроллере

Память ОЗУ в микроконтроллере обычно делится на несколько различных сегментов, включая стек, сегмент данных и сегмент программного кода.

.   Стек - это область памяти, используемая для хранения временных данных и адресов возврата при выполнении программы. Она располагается в верхней части ОЗУ и обычно имеет фиксированный размер.

.   Сегмент данных - это область памяти, используемая для хранения переменных и других данных, необходимых для работы программы. Обычно это самое большое пространство в памяти ОЗУ микроконтроллера.

.   Сегмент программного кода - это область памяти, где хранится исполняемый код программы. Обычно это начинается с адреса, который определн спецификацией и может быть разделено на несколько сегментов для хранения различных функций и подпрограмм.

== Указатель

Указатель — переменная, диапазон значений которой состоит из адресов ячеек памяти или специального значения — нулевого адреса. Последнее используется для указания того, что в данный момент указатель не ссылается ни на одну из допустимых ячеек.

Использование указателей в качестве аргументов функции помогает передать в функцию фактический адрес переменной, и все изменения, выполненные с переменной, будут отражены во внешней функции.

Указатели позволяют программам имитировать вызов по ссылке, а также создавать и манипулировать динамическими структурами данных.

.Указатель
image::ukazatel.jpg[]

Некоторые действия, которые можно делать с указателями:

• Присваивать адрес. Указателю можно присвоить адрес объекта того же типа либо значение другого указателя.

• Разыменовывать указатель. Это позволяет получить объект по адресу, который хранится в указателе. 

• Присваивать нулевое значение. Нулевой указатель — это указатель, который не указывает ни на какой объект.

• Использовать арифметические операции. Сложение и вычитание позволяют перемещаться по массивам и другим структурам данных. Можно вычитать один указатель из другого. Результатом операции вычитания указателей будет количество элементов между указателями, а не сами указатели. Однако, при вычитании указателей необходимо учитывать тип указателя и тип данных, на которые они указывают, чтобы получить корректный результат.



• Применять операции сравнения. Они применяются только к указателям одного типа.

== Измение любой ячейки памяти

Изменить любую ячейку памяти можно например программно, используя языки программирования. Для этого необходимо указать адрес нужной ячейки памяти и присвоить ей новое значение.

int* ptr; //объявляем указатель на целое число

ptr = (int*)0x1000; //указываем адрес нужной ячейки памяти

*ptr =42; //присваиваем новое значение ячейке памяти

Операция * называется разыменованием указателя.

Однако, следует быть осторожным при изменении ячеек памяти напрямую, так как это может привести к непредсказуемым результатам и ошибкам в программе. В большинстве случаев лучше использовать стандартные средства языка программирования для работы с данными.

== Прибавление к указателю типа int и double 1

Когда вы прибавляете 1 к указателю в C++, вы не просто увеличиваете адрес на 1 байт. Вместо этого адрес увеличивается на размер типа, на который указывает указатель.

В стандартной реализации размер типа int обычно составляет 4 байта

Если указатель типа `int` указывает на адрес `1`, то при прибавлении 1 к этому указателю адрес будет увеличен на sizeof(int) (в данном случае 4 байта).Таким образом, новый адрес, на который будет указывать указатель, будет `1 + 4 = 5`.

Размер типа double обычно составляет 8 байт. Если указатель типа double указывает на адрес 1, то при прибавлении 1 к этому указателю адрес будет увеличен на sizeof(double) (в данном случае 8 байт).

Таким образом, новый адрес, на который будет указывать указатель, будет `1 + 8 = 9`.

== Число  в переменной b после разыменовывания указателя

Если в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint32_t указывает на адрес 1, то какое число будет в переменной b после разименовывания указателя?

Если указатель ptr типа std::uint32_t* указывает на адрес 1, и вы разыменовываете этот указатель с помощью *ptr, то вы пытаетесь получить значение, хранящееся по адресу `1`.

Таким образом переменная b будет содержать значение 10.

== Регистр

Регистр — это определённый участок памяти внутри процессора, который используется для промежуточного хранения информации, обрабатываемой процессором. 

.Регистр
image::registr.jpg[]

Регистры могут быть как программно доступными, к которым возможно обратиться из выполняемой программы, так и недоступными программно. Например, при выборке из памяти очередной команды она помещается в регистр команд, обращение к которому программист прописать не может.

Регистры делятся на следующие виды: регистры общего назначения, специальные регистры, системные регистры. В них могут храниться различные данные, необходимые для работы процессора, например, смещения базовых таблиц, уровни доступа. 

== Дизъюнкция и конъюнкция

Конъюнкция  — обозначает объединение двух или нескольких высказываний в одно таким образом, что результат будет истинным тогда и только тогда, когда истинны все входящие в него высказывания.

.Конъюнкция
image::conuc.jpg[]

Дизъюнкция  — обозначает объединение двух или нескольких высказываний в одно таким образом, что результат будет истинным тогда, когда истинно хотя бы одно входящее в него высказывание.

.Дизъюнкция 
image::disunc.jpg[]

== Сброс бита

Для сброса бита в переменной можно использовать битовую операцию AND с инвертированным битом. Например, чтобы сбросить первый бит в переменной x, можно выполнить следующую операцию:

x = x & ~(1 << 0);

Это выражение сбросит первый бит в переменной x, остальные биты останутся неизменными.



== Задание на дом

Задание 1

.Переменная b
image::home1.jpg[]

Переменная b будет объявлена как константный указатель на символ типа const char*. 
Этот указатель указывает на строку, которая содержит символ 'c' и завершается нулевым символом '\0'. 
В языке программирования C++ строка в двойных кавычках ("c") представляет собой массив символов.
При использовании ключевого слова auto переменная b будет автоматически инициализирована указателем на первый символ массива.

Задание 2

.Переменная b1
image::home2.jpg[]

Переменная b1  объявляется с использованием auto и инициализируется символом 'c'. В C++ символы, записанные в одинарных кавычках, имеют тип `char`. 

Задание 3

nt main()
{
auto b = "c";
auto b1 = 'c';
char a = 'A'
int a =0;
int a = 3.14;
bool a = 0;
}

Символ 'A' в  коде будет равен числу 65.

