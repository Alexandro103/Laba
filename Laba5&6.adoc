= Отчет по лабораторной работе №5&6
Шумаков А.С. <КЭ-413>
:imagesdir: image
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:sectnums: |,all|

Целью 5 работы является разделение кода на отдельные классы, в отдельные папки для удобства работы с кодом.

== Определение класса
Класс в объектно-ориентированном программировании представляет собой модель для создания объектов определённого типа. 

Он описывает их структуру (набор полей и начальные значения) и определяет алгоритмы (функции или методы) для взаимодействия с этими объектами.

Проще говоря, класс является инструментом для введения абстрактных типов данных в программный проект.

Другие виды абстрактных типов данных, такие как метаклассы, интерфейсы, структуры и перечисления, обладают своими уникальными характеристиками. 
 
Основное отличие классов заключается в том, что при определении типа данных класс одновременно задаёт как интерфейс, так и реализацию для всех своих экземпляров (то есть объектов), что делает вызов метода-конструктора обязательным.
 
== Диаграмма кода

На следующем рисунке представлена диаграмма кода

.Диаграмма кода
image::Diagram.png[]

== Главный код

[[pointer_code1]]

[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include  "gpiocregisters.hpp" // for GPIOÑ
#include <array>
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" 
#include <array>

#include "ILed.h" 
#include "Led.h" 
#include "ledconfig.h" 


#include "IMode.h" 
#include "allmode.h" 
#include "treemode.h" 
#include "chessmode.h" 
#include "modeconfig.h" 


std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
 {

RCC::CR::HSEON::On::Set();
while (RCC::CR::HSERDY::NotReady::IsSet())
  {

  }

RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }

RCC::APB2ENR::SYSCFGEN::Enable::Set();

return 1;
 }
}

void delay(int cycles)
{
for(int i = 0; i < cycles; ++i)
{
}
}

int main()
{
RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
RCC::AHB1ENR::GPIOCEN::Enable::Set();

GPIOC::MODER::MODER13::Input::Set(); 


GPIOA::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER8::Output::Set() ;
GPIOC::MODER::MODER9::Output::Set() ;




Led<GPIOC, 5> led1;
Led<GPIOC, 8> led2;
Led<GPIOC, 9> led3;
Led<GPIOA, 5> led4;


tLeds leds = {
&led1,
&led2,
&led3,
&led4};


ChessMode chessmode(leds);
    AllMode allmode(leds);
    TreeMode treemode(leds);

    
     treemode.Init();


  for(;;) 
  {
   
 treemode.Update();
  delay(1000000);
  }

  return 1;
}
----

В данном коде управляются светодиоды на микроконтроллере. В начале кода подключаются необходимые заголовочные файлы для работы с регистрами RCC и GPIOA/GPIOC, а также для работы с классами Led, Mode и их конфигурацией.

Затем инициализируется внешний осциллятор на частоте 16 МГц и устанавливается системная частота. Далее включается тактирование портов GPIOA и GPIOC, устанавливаются режимы работы портов (Input/Output) для конкретных пинов, на которых подключены светодиоды.

Создаются объекты светодиодов (Led) с указанием соответствующих порта и пина. Затем создаются объекты режимов работы светодиодов (Mode) - ChessMode, AllMode и TreeMode. В данном случае используется TreeMode.

Затем происходит бесконечный цикл, в котором вызывается метод Update() режима работы для обновления состояния светодиодов и вызова функции задержки delay().

Таким образом, данный код представляет собой программу для управления группой светодиодов с помощью различных режимов работы.

== Разделение на классы

Приведу примеры нескольких классов

Класс allmode:


[[pointer_code2]]
[source, cpp]

----
#include "allmode.h" 
AllMode::AllMode(tLeds& ledsArr) : leds(ledsArr)
{
}

void AllMode::Update()
{
  for(auto it: leds)
  {
    it -> Switch();
  }
}

void AllMode::Init()
{
  for(auto it: leds)
  {
    it -> Light();
  }
}
----

Класс chessmode:

[[pointer_code3]]
[source, cpp]

----

#include "chessmode.h"

ChessMode::ChessMode(tLeds& ledsArr): leds(ledsArr)
{
}
void ChessMode::Update()
{
  for(auto it: leds)
  {
    it->Switch();

  }
}

void ChessMode::Init()
{
  for(auto it: leds)
  {
    it->Light();
  }
  for(auto i=0; i< leds.size(); ++i)
  {
    if ((i % 2)==0)
    {
      leds[i]->Switch();
    }
  }
}
----

Для работы классов нужно было сохранить файлы классов в отдельных папках:

.Фото классов в папке
image::photo papki.jpg[]

А затем создать такие же папки в программе и перенести туда классы

.Фото классов в в программе
image::photo klass.jpg[]

== Вывод по 5 работе

В данной работе исходный код был разбит не несколько отдельных классов для удобства работы

== 6 работа

Целью 6 работы является реалазации кнопки, которая переключает режимы горения светодиодов

== Реализация 6 работы

Для реализации кнопки были введены следующие классы:




ModeManager.cpp :

[[pointer_code4]]
[source, cpp]
----
#include "ModeManager.h"

ModeManager::ModeManager(tMode& modeArr) : modes(modeArr), currentModeType(0) 
{
}

void ModeManager::InitModeManager() {
    if (modes[currentModeType]) {
        modes[currentModeType]->Init();
    }
}

void ModeManager::UpdateModeManager() {
    if (modes[currentModeType]) {
        modes[currentModeType]->Update();
    }
}

void ModeManager::SwitchModeManager() {
    currentModeType = (currentModeType + 1) % 3; 
    if (modes[currentModeType]) {
        modes[currentModeType]->Init();
    }
}
----

Данный класс управляет режимами (modes) в приложении. В конструкторе класса инициализируется массив modes и устанавливается начальное значение currentModeType равное 0.

Метод InitModeManager проверяет наличие текущего режима в массиве modes и вызывает его метод Init().

Метод UpdateModeManager также проверяет наличие текущего режима в массиве modes и вызывает его метод Update().

Метод SwitchModeManager изменяет текущий режим на следующий (по кругу) и вызывает его метод Init(). Также обращает внимание на то, что значение currentModeType при этом зацикливается в диапазоне от 0 до 2.

Общий смысл кода заключается в том, что класс ModeManager предоставляет функционал для управления различными режимами приложения.
[[pointer_code5]]
[source, cpp]

----

Button.h:

#ifndef BUTTON_H
#define BUTTON_H

#include "IButton.h"

template<typename Tport, int punNumber>
class Button : public IButton {
public:
Button() : currentStatus(false), buttonPortStatus(0) {}

bool Click() override {
    return (Tport::IDR::Get() & (1 << punNumber)) == 0;
}
private:
bool currentStatus;
std::uint32_t buttonPortStatus;
};

#endif

----

Данный класс наследуется от интерфейса IButton. Класс имеет два шаблонных параметра: Tport, представляющий тип порта кнопки, и punNumber, представляющий номер порта.

В конструкторе класса инициализируются переменные currentStatus и buttonPortStatus. Метод onClick переопределяет виртуальный метод из интерфейса IButton и возвращает true, если на порте кнопки, указанном в шаблонных параметрах, нажата кнопка (бит с номером punNumber равен 0).

Присутствует приватная переменная currentStatus для хранения текущего состояние кнопки, а также переменная buttonPortStatus типа std::uint32_t для хранения статуса порта кнопки.


main.c :
[[pointer_code6]]
[source, cpp]

----

tLeds leds = { &led1, &led2, &led3, &led4 };

    TreeMode TreeMode(leds);
    ChessMode ChessMode(leds);
    AllMode AllMode(leds);

    tMode modes = { &TreeMode, &ChessMode, &AllMode };

    ModeManager modeManager(modes);
    modeManager.InitModeManager();

    Button<GPIOC, 13> button;

    for (;;) {
    if (button.Click()) {
        delay(100000);
        if (button.Click()) {
            modeManager.SwitchModeManager();
            delay(1000000);
        }
    }

    modeManager.UpdateModeManager();
    delay(1000000);
}

    return 0;
}
----

Этот код создает несколько объектов классов и управляет переключением между различными "режимами".

Сначала создаются объекты класса tLeds с указателями на объекты LED. Затем создаются объекты классов TreeMode, ChessMode и AllMode, каждый из которых принимает tLeds в качестве параметра конструктора. Далее создается объект modeManager, который принимает массив указателей на объекты различных режимов.

Далее создается объект Button для управления переключением режимов. В бесконечном цикле происходит проверка нажатия кнопки - если кнопка нажата дважды, то происходит переключение между режимами, после чего происходит задержка. В противном случае происходит обновление текущего режима и также происходит задержка.

== Вывод по 6 работе

Была реализавона кнопка, которая переключает режимы светодиов между елочкой, шахматами и allmode